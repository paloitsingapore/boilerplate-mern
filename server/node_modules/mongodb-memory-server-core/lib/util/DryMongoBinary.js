"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DryMongoBinary = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const debug_1 = tslib_1.__importDefault(require("debug"));
const resolveConfig_1 = require("./resolveConfig");
const utils_1 = require("./utils");
const path = tslib_1.__importStar(require("path"));
const os_1 = require("os");
const find_cache_dir_1 = tslib_1.__importDefault(require("find-cache-dir"));
const getos_1 = tslib_1.__importStar(require("./getos"));
const log = debug_1.default('MongoMS:DryMongoBinary');
/**
 * Locate an Binary, without downloading / locking
 */
class DryMongoBinary {
    /**
     * Try to locate an existing binary
     * @returns The Path to an Binary Found, or undefined
     */
    static locateBinary(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log(`locateBinary: Trying to locate Binary for version "${opts.version}"`);
            const useOpts = yield this.generateOptions(opts);
            if (!!useOpts.systemBinary) {
                log(`locateBinary: env "SYSTEM_BINARY" was provided with value: "${useOpts.systemBinary}"`);
                const systemReturn = yield this.getSystemPath(useOpts.systemBinary);
                if (utils_1.isNullOrUndefined(systemReturn)) {
                    throw new Error(`Config option "SYSTEM_BINARY" was provided with value "${useOpts.systemBinary}", but no binary could be found!`);
                }
                return systemReturn;
            }
            if (this.binaryCache.has(opts.version)) {
                const binary = this.binaryCache.get(opts.version);
                log(`locateBinary: Requested Version found in cache: "[${opts.version}, ${binary}]"`);
                return binary;
            }
            log('locateBinary: running generateDownloadPath');
            const returnValue = yield this.generateDownloadPath(useOpts);
            if (!returnValue[0]) {
                log('locateBinary: could not find an existing binary');
                return undefined;
            }
            log(`locateBinary: found binary at "${returnValue[1]}"`);
            this.binaryCache.set(opts.version, returnValue[1]);
            return returnValue[1];
        });
    }
    /**
     * Generate All required options for the binary name / path generation
     */
    static generateOptions(opts) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log('generateOptions');
            const defaultVersion = (_a = resolveConfig_1.resolveConfig(resolveConfig_1.ResolveConfigVariables.VERSION)) !== null && _a !== void 0 ? _a : '4.0.25';
            const ensuredOpts = utils_1.isNullOrUndefined(opts)
                ? { version: defaultVersion }
                : opts;
            if (utils_1.isNullOrUndefined(this.cachedGetOs)) {
                this.cachedGetOs = yield getos_1.default();
            }
            const final = {
                version: ensuredOpts.version || defaultVersion,
                downloadDir: resolveConfig_1.resolveConfig(resolveConfig_1.ResolveConfigVariables.DOWNLOAD_DIR) || ensuredOpts.downloadDir || '',
                os: (_b = ensuredOpts.os) !== null && _b !== void 0 ? _b : this.cachedGetOs,
                arch: ensuredOpts.arch || os_1.arch(),
                systemBinary: resolveConfig_1.resolveConfig(resolveConfig_1.ResolveConfigVariables.SYSTEM_BINARY) || ensuredOpts.systemBinary || '',
            };
            final.downloadDir = path.dirname((yield this.generateDownloadPath(final))[1]);
            return final;
        });
    }
    /**
     * Get the full path with filename
     * @return Absoulte Path with FileName
     */
    static getBinaryName(opts) {
        log('getBinaryName');
        const addExe = os_1.platform() === 'win32' ? '.exe' : '';
        const dist = getos_1.isLinuxOS(opts.os) ? opts.os.dist : opts.os.os;
        return `mongod-${opts.arch}-${dist}-${opts.version}${addExe}`;
    }
    /**
     * Combine basePath with binaryName
     */
    static combineBinaryName(basePath, binaryName) {
        log('combineBinaryName');
        return path.resolve(basePath, binaryName);
    }
    /**
     * Probe if the provided "systemBinary" is an existing path
     * @param systemBinary The Path to probe for an System-Binary
     * @return System Binary path or undefined
     */
    static getSystemPath(systemBinary) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log('getSystempath');
            try {
                yield fs_1.promises.access(systemBinary, fs_1.constants.X_OK); // check if the provided path exists and has the execute bit for current user
                log(`getSystemPath: found system binary path at "${systemBinary}"`);
                return systemBinary; // returns if "access" is successful
            }
            catch (err) {
                log(`getSystemPath: can't find system binary at "${systemBinary}".\n${err.message}`);
            }
            return undefined;
        });
    }
    /**
     * Generate an "MongoBinaryPaths" object
     *
     * This Function should not hit the FileSystem
     * @return an finished "MongoBinaryPaths" object
     */
    static generatePaths(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log('generatePaths');
            const final = {
                legacyHomeCache: '',
                modulesCache: '',
                relative: '',
                resolveConfig: '',
            };
            const binaryName = this.getBinaryName(opts);
            // Assign "node_modules/.cache" to modulesCache
            // if we're in postinstall script, npm will set the cwd too deep
            // when in postinstall, npm will provide an "INIT_CWD" env variable
            let nodeModulesDLDir = process.env['INIT_CWD'] || process.cwd();
            // as long as "node_modules/mongodb-memory-server*" is included in the path, go the paths up
            while (nodeModulesDLDir.includes(`node_modules${path.sep}mongodb-memory-server`)) {
                nodeModulesDLDir = path.resolve(nodeModulesDLDir, '..', '..');
            }
            const tmpModulesCache = find_cache_dir_1.default({
                name: 'mongodb-memory-server',
                cwd: nodeModulesDLDir,
            });
            if (!utils_1.isNullOrUndefined(tmpModulesCache)) {
                final.modulesCache = this.combineBinaryName(path.resolve(tmpModulesCache), binaryName);
            }
            const legacyHomeCache = path.resolve(this.homedir(), '.cache/mongodb-binaries');
            final.legacyHomeCache = this.combineBinaryName(legacyHomeCache, binaryName);
            // Resolve the config value "DOWNLOAD_DIR" if provided, otherwise remove from list
            const resolveConfigValue = opts.downloadDir || resolveConfig_1.resolveConfig(resolveConfig_1.ResolveConfigVariables.DOWNLOAD_DIR);
            if (!utils_1.isNullOrUndefined(resolveConfigValue) && resolveConfigValue.length > 0) {
                log(`generatePaths: resolveConfigValue is not empty`);
                final.resolveConfig = this.combineBinaryName(resolveConfigValue, binaryName);
            }
            // Resolve relative to cwd if no other has been found
            final.relative = this.combineBinaryName(path.resolve(process.cwd(), 'mongodb-binaries'), binaryName);
            return final;
        });
    }
    /**
     * Generate the Path where an Binary will be located
     * @return "boolean" indicating if the binary exists at the provided path, and "string" the path to use for the binary
     */
    static generateDownloadPath(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const preferGlobal = resolveConfig_1.envToBool(resolveConfig_1.resolveConfig(resolveConfig_1.ResolveConfigVariables.PREFER_GLOBAL_PATH));
            log(`generateDownloadPath: Generating Download Path, preferGlobal: "${preferGlobal}"`);
            const paths = yield this.generatePaths(opts);
            log('generateDownloadPath: Paths:', paths, opts.systemBinary);
            // SystemBinary will only be returned if defined and paths exists
            if (!!opts.systemBinary && (yield utils_1.pathExists(opts.systemBinary))) {
                const sysPath = yield this.getSystemPath(opts.systemBinary);
                if (!utils_1.isNullOrUndefined(sysPath)) {
                    return [true, sysPath];
                }
            }
            // Section where paths are probed for an existing binary
            if (yield utils_1.pathExists(paths.resolveConfig)) {
                log(`generateDownloadPath: Found binary in resolveConfig (DOWNLOAD_DIR): "${paths.resolveConfig}"`);
                return [true, paths.resolveConfig];
            }
            if (yield utils_1.pathExists(paths.legacyHomeCache)) {
                log(`generateDownloadPath: Found binary in legacyHomeCache: "${paths.legacyHomeCache}"`);
                return [true, paths.legacyHomeCache];
            }
            if (yield utils_1.pathExists(paths.modulesCache)) {
                log(`generateDownloadPath: Found binary in modulesCache: "${paths.modulesCache}"`);
                return [true, paths.modulesCache];
            }
            if (yield utils_1.pathExists(paths.relative)) {
                log(`generateDownloadPath: Found binary in relative: "${paths.relative}"`);
                return [true, paths.relative];
            }
            // Section where binary path gets generated when no binary was found
            log(`generateDownloadPath: no existing binary for version "${opts.version}" was found`);
            if (paths.resolveConfig.length > 0) {
                log(`generateDownloadPath: using resolveConfig (DOWNLOAD_DIR) "${paths.resolveConfig}"`);
                return [false, paths.resolveConfig];
            }
            if (preferGlobal && !!paths.legacyHomeCache) {
                log(`generateDownloadPath: using global (preferGlobal) "${paths.legacyHomeCache}"`);
                return [false, paths.legacyHomeCache];
            }
            // this case may not happen, if somehow the cwd gets changed outside of "node_modules" reach
            if (paths.modulesCache.length > 0) {
                log(`generateDownloadPath: using modulesCache "${paths.modulesCache}"`);
                return [false, paths.modulesCache];
            }
            log(`generateDownloadPath: using relative "${paths.relative}"`);
            return [false, paths.relative];
        });
    }
    /**
     * This function is used, because jest just dosnt want "os.homedir" to be mocked
     * if someone can find an way to actually mock this in an test, please change it
     */
    static homedir() {
        return os_1.homedir();
    }
}
exports.DryMongoBinary = DryMongoBinary;
/**
 * Binaries already found, values are: [Version, Path]
 */
DryMongoBinary.binaryCache = new Map();
//# sourceMappingURL=DryMongoBinary.js.map