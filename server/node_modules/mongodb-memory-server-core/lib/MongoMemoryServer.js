"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoMemoryServer = exports.MongoMemoryServerStates = exports.MongoMemoryServerEvents = void 0;
const tslib_1 = require("tslib");
const tmp = tslib_1.__importStar(require("tmp"));
const get_port_1 = tslib_1.__importDefault(require("get-port"));
const utils_1 = require("./util/utils");
const MongoInstance_1 = require("./util/MongoInstance");
const debug_1 = tslib_1.__importDefault(require("debug"));
const events_1 = require("events");
const fs_1 = require("fs");
const mongodb_1 = require("mongodb");
const semver_1 = require("semver");
const errors_1 = require("./util/errors");
const log = debug_1.default('MongoMS:MongoMemoryServer');
tmp.setGracefulCleanup();
/**
 * All Events for "MongoMemoryServer"
 */
var MongoMemoryServerEvents;
(function (MongoMemoryServerEvents) {
    MongoMemoryServerEvents["stateChange"] = "stateChange";
})(MongoMemoryServerEvents = exports.MongoMemoryServerEvents || (exports.MongoMemoryServerEvents = {}));
/**
 * All States for "MongoMemoryServer._state"
 */
var MongoMemoryServerStates;
(function (MongoMemoryServerStates) {
    MongoMemoryServerStates["new"] = "new";
    MongoMemoryServerStates["starting"] = "starting";
    MongoMemoryServerStates["running"] = "running";
    MongoMemoryServerStates["stopped"] = "stopped";
})(MongoMemoryServerStates = exports.MongoMemoryServerStates || (exports.MongoMemoryServerStates = {}));
class MongoMemoryServer extends events_1.EventEmitter {
    /**
     * Create an Mongo-Memory-Sever Instance
     * @param opts Mongo-Memory-Sever Options
     */
    constructor(opts) {
        super();
        /**
         * The Current State of this instance
         */
        this._state = MongoMemoryServerStates.new;
        this.opts = Object.assign({}, opts);
        if (!utils_1.isNullOrUndefined(this.opts.auth)) {
            // assign defaults
            this.auth = utils_1.authDefault(this.opts.auth);
        }
    }
    /**
     * Create an Mongo-Memory-Sever Instance that can be awaited
     * @param opts Mongo-Memory-Sever Options
     */
    static create(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log('create: Called .create() method');
            const instance = new MongoMemoryServer(Object.assign({}, opts));
            yield instance.start();
            return instance;
        });
    }
    /**
     * Change "this._state" to "newState" and emit "stateChange" with "newState"
     * @param newState The new State to set & emit
     */
    stateChange(newState) {
        this._state = newState;
        this.emit(MongoMemoryServerEvents.stateChange, newState);
    }
    /**
     * Start the Mongod Instance
     * @param forceSamePort Force to use the Same Port, if already an "instanceInfo" exists
     * @throws if state is not "new" or "stopped"
     */
    start(forceSamePort = false) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log('start: Called .start() method');
            switch (this._state) {
                case MongoMemoryServerStates.new:
                case MongoMemoryServerStates.stopped:
                    break;
                case MongoMemoryServerStates.running:
                case MongoMemoryServerStates.starting:
                default:
                    throw new errors_1.StateError([MongoMemoryServerStates.new, MongoMemoryServerStates.stopped], this.state);
            }
            utils_1.assertion(utils_1.isNullOrUndefined((_a = this._instanceInfo) === null || _a === void 0 ? void 0 : _a.instance.mongodProcess), new Error('Cannot start because "instance.mongodProcess" is already defined!'));
            this.stateChange(MongoMemoryServerStates.starting);
            // check if not replset (because MongoMemoryReplSet has an own beforeExit listener) and
            // check if an "beforeExit" listener for "this.cleanup" is already defined for this class, if not add one
            if (utils_1.isNullOrUndefined((_b = this.opts.instance) === null || _b === void 0 ? void 0 : _b.replSet) &&
                process
                    .listeners('beforeExit')
                    .findIndex((f) => f === this.cleanup) <= -1) {
                process.on('beforeExit', this.cleanup);
            }
            yield this._startUpInstance(forceSamePort).catch((err) => {
                if (!debug_1.default.enabled('MongoMS:MongoMemoryServer')) {
                    console.warn('Starting the instance failed, enable debug for more information');
                }
                this.stateChange(MongoMemoryServerStates.stopped);
                throw err;
            });
            this.stateChange(MongoMemoryServerStates.running);
            log('start: Instance fully Started');
        });
    }
    /**
     * Find an new unlocked port
     * @param port An User defined default port
     */
    getNewPort(port) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const newPort = yield get_port_1.default({ port });
            // only log this message if an custom port was provided
            if (port != newPort && typeof port === 'number') {
                log(`getNewPort: starting with port "${newPort}", since "${port}" was locked`);
            }
            return newPort;
        });
    }
    /**
     * Construct Instance Starting Options
     */
    getStartOptions() {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log('getStartOptions');
            /** Shortcut to this.opts.instance */
            const instOpts = (_a = this.opts.instance) !== null && _a !== void 0 ? _a : {};
            /**
             * This variable is used for determining if "createAuth" should be run
             */
            let isNew = true;
            const data = {
                port: yield this.getNewPort(instOpts.port),
                dbName: utils_1.generateDbName(instOpts.dbName),
                ip: (_b = instOpts.ip) !== null && _b !== void 0 ? _b : '127.0.0.1',
                storageEngine: (_c = instOpts.storageEngine) !== null && _c !== void 0 ? _c : 'ephemeralForTest',
                replSet: instOpts.replSet,
                dbPath: instOpts.dbPath,
                tmpDir: undefined,
            };
            if (utils_1.isNullOrUndefined(this._instanceInfo)) {
                // create an tmpDir instance if no "dbPath" is given
                if (!data.dbPath) {
                    data.tmpDir = tmp.dirSync({
                        mode: 0o755,
                        prefix: 'mongo-mem-',
                        unsafeCleanup: true,
                    });
                    data.dbPath = data.tmpDir.name;
                    isNew = true; // just to ensure "isNew" is "true" because an new temporary directory got created
                }
                else {
                    log(`getStartOptions: Checking if "${data.dbPath}}" (no new tmpDir) already has data`);
                    const files = yield fs_1.promises.readdir(data.dbPath);
                    isNew = files.length > 0; // if there already files in the directory, assume that the database is not new
                }
            }
            else {
                isNew = false;
            }
            const createAuth = !!instOpts.auth && // check if auth is even meant to be enabled
                !utils_1.isNullOrUndefined(this.auth) && // check if "this.auth" is defined
                !this.auth.disable && // check that "this.auth.disable" is falsey
                (this.auth.force || isNew) && // check that either "isNew" or "this.auth.force" is "true"
                !instOpts.replSet; // dont run "createAuth" when its an replset
            return {
                data: data,
                createAuth: createAuth,
                mongodOptions: {
                    instance: Object.assign(Object.assign({}, data), { args: instOpts.args, auth: createAuth ? false : instOpts.auth }),
                    binary: this.opts.binary,
                    spawn: this.opts.spawn,
                },
            };
        });
    }
    /**
     * Internal Function to start an instance
     * @param forceSamePort Force to use the Same Port, if already an "instanceInfo" exists
     * @private
     */
    _startUpInstance(forceSamePort = false) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log('_startUpInstance: Called MongoMemoryServer._startUpInstance() method');
            if (!utils_1.isNullOrUndefined(this._instanceInfo)) {
                log('_startUpInstance: "instanceInfo" already defined, reusing instance');
                if (!forceSamePort) {
                    const newPort = yield this.getNewPort(this._instanceInfo.port);
                    this._instanceInfo.instance.instanceOpts.port = newPort;
                    this._instanceInfo.port = newPort;
                }
                yield this._instanceInfo.instance.start();
                return;
            }
            const { mongodOptions, createAuth, data } = yield this.getStartOptions();
            log(`_startUpInstance: Creating new MongoDB instance with options: ${JSON.stringify(mongodOptions)}`);
            const instance = yield MongoInstance_1.MongoInstance.create(mongodOptions);
            log('_startUpInstance: Instance Started');
            // "isNullOrUndefined" because otherwise typescript complains about "this.auth" possibly being not defined
            if (!utils_1.isNullOrUndefined(this.auth) && createAuth) {
                log(`_startUpInstance: Running "createAuth" (force: "${this.auth.force}")`);
                yield this.createAuth(data);
                if (data.storageEngine !== 'ephemeralForTest') {
                    log('_startUpInstance: Killing No-Auth instance');
                    yield instance.stop();
                    log('_startUpInstance: Starting Auth Instance');
                    instance.instanceOpts.auth = true;
                    yield instance.start();
                }
                else {
                    console.warn('Not Restarting MongoInstance for Auth\n' +
                        'Storage engine is "ephemeralForTest", which does not write data on shutdown, and mongodb does not allow changing "auth" runtime');
                }
            }
            else {
                // extra "if" to log when "disable" is set to "true"
                if ((_a = this.opts.auth) === null || _a === void 0 ? void 0 : _a.disable) {
                    log('_startUpInstance: AutomaticAuth.disable is set to "true" skipping "createAuth"');
                }
            }
            this._instanceInfo = Object.assign(Object.assign({}, data), { dbPath: data.dbPath, // because otherwise the types would be incompatible
                instance });
        });
    }
    /**
     * Stop the current In-Memory Instance
     * @param runCleanup run "this.cleanup"? (remove dbPath & reset "instanceInfo")
     */
    stop(runCleanup = true) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log('stop: Called .stop() method');
            // just return "true" if there was never an instance
            if (utils_1.isNullOrUndefined(this._instanceInfo)) {
                log('stop: "instanceInfo" is not defined (never ran?)');
                return false;
            }
            if (this._state === MongoMemoryServerStates.stopped) {
                log(`stop: state is "stopped", so already stopped`);
                return false;
            }
            // assert here, otherwise typescript is not happy
            utils_1.assertion(!utils_1.isNullOrUndefined(this._instanceInfo.instance), new Error('"instanceInfo.instance" is undefined!'));
            log(`stop: Stopping MongoDB server on port ${this._instanceInfo.port} with pid ${(_a = this._instanceInfo.instance.mongodProcess) === null || _a === void 0 ? void 0 : _a.pid}` // "undefined" would say more than ""
            );
            yield this._instanceInfo.instance.stop();
            this.stateChange(MongoMemoryServerStates.stopped);
            if (runCleanup) {
                yield this.cleanup(false);
            }
            return true;
        });
    }
    cleanup(force = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof force !== 'boolean') {
                force = false;
            }
            assertionIsMMSState(MongoMemoryServerStates.stopped, this.state);
            process.removeListener('beforeExit', this.cleanup);
            if (utils_1.isNullOrUndefined(this._instanceInfo)) {
                log('cleanup: "instanceInfo" is undefined');
                return;
            }
            utils_1.assertion(utils_1.isNullOrUndefined(this._instanceInfo.instance.mongodProcess), new Error('Cannot cleanup because "instance.mongodProcess" is still defined'));
            log(`cleanup: force ${force}`);
            const tmpDir = this._instanceInfo.tmpDir;
            if (!utils_1.isNullOrUndefined(tmpDir)) {
                log(`cleanup: removing tmpDir at ${tmpDir.name}`);
                tmpDir.removeCallback();
            }
            if (force) {
                const dbPath = this._instanceInfo.dbPath;
                const res = yield utils_1.statPath(dbPath);
                if (utils_1.isNullOrUndefined(res)) {
                    log(`cleanup: force is true, but path "${dbPath}" dosnt exist anymore`);
                }
                else {
                    utils_1.assertion(res.isDirectory(), new Error('Defined dbPath is not an directory'));
                    if (semver_1.lt(process.version, '14.14.0')) {
                        // this has to be used for 12.10 - 14.13 (inclusive) because ".rm" did not exist yet
                        yield fs_1.promises.rmdir(dbPath, { recursive: true, maxRetries: 1 });
                    }
                    else {
                        // this has to be used for 14.14+ (inclusive) because ".rmdir" and "recursive" got deprecated (DEP0147)
                        yield fs_1.promises.rm(dbPath, { recursive: true, maxRetries: 1 });
                    }
                }
            }
            this.stateChange(MongoMemoryServerStates.new); // reset "state" to new, because the dbPath got removed
            this._instanceInfo = undefined;
        });
    }
    /**
     * Get Information about the currently running instance, if it is not running it returns "undefined"
     */
    get instanceInfo() {
        return this._instanceInfo;
    }
    /**
     * Get Current state of this class
     */
    get state() {
        return this._state;
    }
    /**
     * Ensure that the instance is running
     * -> throws if instance cannot be started
     */
    ensureInstance() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log('ensureInstance: Called .ensureInstance() method');
            switch (this._state) {
                case MongoMemoryServerStates.running:
                    if (this._instanceInfo) {
                        return this._instanceInfo;
                    }
                    throw new Error('MongoMemoryServer "_state" is "running" but "instanceInfo" is undefined!');
                case MongoMemoryServerStates.new:
                case MongoMemoryServerStates.stopped:
                    break;
                case MongoMemoryServerStates.starting:
                    return new Promise((res, rej) => this.once(MongoMemoryServerEvents.stateChange, (state) => {
                        if (state != MongoMemoryServerStates.running) {
                            rej(new Error(`"ensureInstance" waited for "running" but got an different state: "${state}"`));
                            return;
                        }
                        // this assertion is mainly for types (typescript otherwise would complain that "_instanceInfo" might be "undefined")
                        utils_1.assertion(!utils_1.isNullOrUndefined(this._instanceInfo), new Error('InstanceInfo is undefined!'));
                        res(this._instanceInfo);
                    }));
                default:
                    throw new errors_1.StateError([
                        MongoMemoryServerStates.running,
                        MongoMemoryServerStates.new,
                        MongoMemoryServerStates.stopped,
                        MongoMemoryServerStates.starting,
                    ], this.state);
            }
            log('ensureInstance: no running instance, calling "start()" command');
            yield this.start();
            log('ensureInstance: "start()" command was succesfully resolved');
            // check again for 1. Typescript-type reasons and 2. if .start failed to throw an error
            if (!this._instanceInfo) {
                throw new Error('Ensure-Instance failed to start an instance!');
            }
            return this._instanceInfo;
        });
    }
    /**
     * Generate the Connection string used by mongodb
     * @param otherDb add an database into the uri (in mongodb its the auth database, in mongoose its the default database for models)
     * @return an valid mongo URI, by the definition of https://docs.mongodb.com/manual/reference/connection-string/
     */
    getUri(otherDb) {
        log('getUri:', this.state);
        switch (this.state) {
            case MongoMemoryServerStates.running:
            case MongoMemoryServerStates.starting:
                break;
            case MongoMemoryServerStates.stopped:
            default:
                throw new errors_1.StateError([MongoMemoryServerStates.running, MongoMemoryServerStates.starting], this.state);
        }
        assertionInstanceInfo(this._instanceInfo);
        return utils_1.uriTemplate(this._instanceInfo.ip, this._instanceInfo.port, utils_1.generateDbName(otherDb));
    }
    /**
     * Create Users and restart instance to enable auth
     * This Function assumes "this.opts.auth" is already processed into "this.auth"
     * @param data Used to get "ip" and "port"
     * @internal
     */
    createAuth(data) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            utils_1.assertion(!utils_1.isNullOrUndefined(this.auth), new Error('"createAuth" got called, but "this.auth" is undefined!'));
            log('createAuth: options:', this.auth);
            const con = yield mongodb_1.MongoClient.connect(utils_1.uriTemplate(data.ip, data.port, 'admin'), {
                useNewUrlParser: true,
                useUnifiedTopology: true,
            });
            let db = con.db('admin'); // just to ensure it is actually the "admin" database AND to have the "Db" data
            // Create the root user
            log(`createAuth: Creating Root user, name: "${this.auth.customRootName}"`);
            yield db.command({
                createUser: this.auth.customRootName,
                pwd: 'rootuser',
                mechanisms: ['SCRAM-SHA-256'],
                customData: {
                    createdBy: 'mongodb-memory-server',
                    as: 'ROOTUSER',
                },
                roles: ['root'],
            });
            if (this.auth.extraUsers.length > 0) {
                log(`createAuth: Creating "${this.auth.extraUsers.length}" Custom Users`);
                this.auth.extraUsers.sort((a, b) => {
                    if (a.database === 'admin') {
                        return -1; // try to make all "admin" at the start of the array
                    }
                    return a.database === b.database ? 0 : 1; // "0" to sort same databases continuesly, "-1" if nothing before/above applies
                });
                for (const user of this.auth.extraUsers) {
                    user.database = utils_1.isNullOrUndefined(user.database) ? 'admin' : user.database;
                    // just to have not to call "con.db" everytime in the loop if its the same
                    if (user.database !== db.databaseName) {
                        db = con.db(user.database);
                    }
                    log('createAuth: Creating User: ', user);
                    yield db.command({
                        createUser: user.createUser,
                        pwd: user.pwd,
                        customData: Object.assign(Object.assign({}, user.customData), { createdBy: 'mongodb-memory-server', as: 'EXTRAUSER' }),
                        roles: user.roles,
                        authenticationRestrictions: (_a = user.authenticationRestrictions) !== null && _a !== void 0 ? _a : [],
                        mechanisms: (_b = user.mechanisms) !== null && _b !== void 0 ? _b : ['SCRAM-SHA-256'],
                        digestPassword: (_c = user.digestPassword) !== null && _c !== void 0 ? _c : true,
                    });
                }
            }
            yield con.close();
        });
    }
}
exports.MongoMemoryServer = MongoMemoryServer;
exports.default = MongoMemoryServer;
/**
 * This function is to de-duplicate code
 * -> this couldnt be included in the class, because "asserts this.instanceInfo" is not allowed
 * @param val this.instanceInfo
 */
function assertionInstanceInfo(val) {
    utils_1.assertion(!utils_1.isNullOrUndefined(val), new Error('"instanceInfo" is undefined'));
}
/**
 * Helper function to de-duplicate state checking for "MongoMemoryServerStates"
 * @param wantedState The State that is wanted
 * @param currentState The current State ("this._state")
 */
function assertionIsMMSState(wantedState, currentState) {
    utils_1.assertion(currentState === wantedState, new errors_1.StateError([wantedState], currentState));
}
//# sourceMappingURL=MongoMemoryServer.js.map